#!/usr/bin/env python3
"""
Cat's Chip 8 Emulator
A complete CHIP-8 emulator with Tkinter GUI
Styled after Project64 1.0 interface
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import random
import time
import threading
from typing import Optional
import os


# CHIP-8 Font Set (0-F characters, 5 bytes each)
FONTSET = [
    0xF0, 0x90, 0x90, 0x90, 0xF0,  # 0
    0x20, 0x60, 0x20, 0x20, 0x70,  # 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0,  # 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0,  # 3
    0x90, 0x90, 0xF0, 0x10, 0x10,  # 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0,  # 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0,  # 6
    0xF0, 0x10, 0x20, 0x40, 0x40,  # 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0,  # 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0,  # 9
    0xF0, 0x90, 0xF0, 0x90, 0x90,  # A
    0xE0, 0x90, 0xE0, 0x90, 0xE0,  # B
    0xF0, 0x80, 0x80, 0x80, 0xF0,  # C
    0xE0, 0x90, 0x90, 0x90, 0xE0,  # D
    0xF0, 0x80, 0xF0, 0x80, 0xF0,  # E
    0xF0, 0x80, 0xF0, 0x80, 0x80,  # F
]

# Keyboard mapping: CHIP-8 keypad to PC keyboard
# CHIP-8 Keypad:    PC Keyboard:
# 1 2 3 C          1 2 3 4
# 4 5 6 D          Q W E R
# 7 8 9 E          A S D F
# A 0 B F          Z X C V
KEY_MAP = {
    '1': 0x1, '2': 0x2, '3': 0x3, '4': 0xC,
    'q': 0x4, 'w': 0x5, 'e': 0x6, 'r': 0xD,
    'a': 0x7, 's': 0x8, 'd': 0x9, 'f': 0xE,
    'z': 0xA, 'x': 0x0, 'c': 0xB, 'v': 0xF,
}


class Chip8CPU:
    """Complete CHIP-8 CPU implementation with all 35 opcodes"""

    def __init__(self):
        self.reset()

    def reset(self):
        """Reset CPU to initial state"""
        # 4KB RAM
        self.memory = [0] * 4096

        # 16 8-bit general purpose registers V0-VF
        self.V = [0] * 16

        # 16-bit index register
        self.I = 0

        # 16-bit program counter (starts at 0x200)
        self.PC = 0x200

        # 8-bit stack pointer
        self.SP = 0

        # 16-level stack
        self.stack = [0] * 16

        # 8-bit delay timer
        self.delay_timer = 0

        # 8-bit sound timer
        self.sound_timer = 0

        # 64x32 display (1 = pixel on, 0 = pixel off)
        self.display = [[0] * 64 for _ in range(32)]

        # Draw flag - indicates display needs update
        self.draw_flag = False

        # Sound flag - indicates sound should play
        self.sound_flag = False

        # Keypad state (16 keys)
        self.keys = [0] * 16

        # Waiting for key press (for FX0A)
        self.waiting_for_key = False
        self.key_register = 0

        # Running state
        self.running = False
        self.paused = False

        # Load fontset into memory (0x000-0x04F)
        for i, byte in enumerate(FONTSET):
            self.memory[i] = byte

    def load_rom(self, rom_data: bytes) -> bool:
        """Load ROM data into memory starting at 0x200"""
        if len(rom_data) > 4096 - 512:
            return False

        self.reset()
        for i, byte in enumerate(rom_data):
            self.memory[0x200 + i] = byte
        return True

    def cycle(self):
        """Execute one CPU cycle"""
        if self.paused or self.waiting_for_key:
            return

        # Fetch opcode (2 bytes)
        opcode = (self.memory[self.PC] << 8) | self.memory[self.PC + 1]

        # Decode and execute
        self.execute(opcode)

    def execute(self, opcode: int):
        """Decode and execute a single opcode"""
        # Extract common values
        nnn = opcode & 0x0FFF  # 12-bit address
        nn = opcode & 0x00FF   # 8-bit constant
        n = opcode & 0x000F    # 4-bit constant
        x = (opcode & 0x0F00) >> 8  # 4-bit register identifier
        y = (opcode & 0x00F0) >> 4  # 4-bit register identifier

        # First nibble determines instruction type
        first = (opcode & 0xF000) >> 12

        if opcode == 0x00E0:
            # 00E0: Clear screen
            self.display = [[0] * 64 for _ in range(32)]
            self.draw_flag = True
            self.PC += 2

        elif opcode == 0x00EE:
            # 00EE: Return from subroutine
            self.SP -= 1
            self.PC = self.stack[self.SP]
            self.PC += 2

        elif first == 0x0:
            # 0NNN: Call RCA 1802 program (ignored on modern interpreters)
            self.PC += 2

        elif first == 0x1:
            # 1NNN: Jump to address NNN
            self.PC = nnn

        elif first == 0x2:
            # 2NNN: Call subroutine at NNN
            self.stack[self.SP] = self.PC
            self.SP += 1
            self.PC = nnn

        elif first == 0x3:
            # 3XNN: Skip next if VX == NN
            if self.V[x] == nn:
                self.PC += 4
            else:
                self.PC += 2

        elif first == 0x4:
            # 4XNN: Skip next if VX != NN
            if self.V[x] != nn:
                self.PC += 4
            else:
                self.PC += 2

        elif first == 0x5 and n == 0:
            # 5XY0: Skip next if VX == VY
            if self.V[x] == self.V[y]:
                self.PC += 4
            else:
                self.PC += 2

        elif first == 0x6:
            # 6XNN: Set VX = NN
            self.V[x] = nn
            self.PC += 2

        elif first == 0x7:
            # 7XNN: Set VX = VX + NN (no carry flag)
            self.V[x] = (self.V[x] + nn) & 0xFF
            self.PC += 2

        elif first == 0x8:
            if n == 0x0:
                # 8XY0: Set VX = VY
                self.V[x] = self.V[y]
                self.PC += 2

            elif n == 0x1:
                # 8XY1: Set VX = VX OR VY
                self.V[x] |= self.V[y]
                self.V[0xF] = 0  # Reset VF (quirk)
                self.PC += 2

            elif n == 0x2:
                # 8XY2: Set VX = VX AND VY
                self.V[x] &= self.V[y]
                self.V[0xF] = 0  # Reset VF (quirk)
                self.PC += 2

            elif n == 0x3:
                # 8XY3: Set VX = VX XOR VY
                self.V[x] ^= self.V[y]
                self.V[0xF] = 0  # Reset VF (quirk)
                self.PC += 2

            elif n == 0x4:
                # 8XY4: Set VX = VX + VY, VF = carry
                result = self.V[x] + self.V[y]
                self.V[x] = result & 0xFF
                self.V[0xF] = 1 if result > 255 else 0
                self.PC += 2

            elif n == 0x5:
                # 8XY5: Set VX = VX - VY, VF = NOT borrow
                borrow = 0 if self.V[x] < self.V[y] else 1
                self.V[x] = (self.V[x] - self.V[y]) & 0xFF
                self.V[0xF] = borrow
                self.PC += 2

            elif n == 0x6:
                # 8XY6: Set VX = VY >> 1, VF = LSB before shift
                lsb = self.V[y] & 0x1
                self.V[x] = self.V[y] >> 1
                self.V[0xF] = lsb
                self.PC += 2

            elif n == 0x7:
                # 8XY7: Set VX = VY - VX, VF = NOT borrow
                borrow = 0 if self.V[y] < self.V[x] else 1
                self.V[x] = (self.V[y] - self.V[x]) & 0xFF
                self.V[0xF] = borrow
                self.PC += 2

            elif n == 0xE:
                # 8XYE: Set VX = VY << 1, VF = MSB before shift
                msb = (self.V[y] & 0x80) >> 7
                self.V[x] = (self.V[y] << 1) & 0xFF
                self.V[0xF] = msb
                self.PC += 2
            else:
                self.PC += 2

        elif first == 0x9 and n == 0:
            # 9XY0: Skip next if VX != VY
            if self.V[x] != self.V[y]:
                self.PC += 4
            else:
                self.PC += 2

        elif first == 0xA:
            # ANNN: Set I = NNN
            self.I = nnn
            self.PC += 2

        elif first == 0xB:
            # BNNN: Jump to NNN + V0
            self.PC = nnn + self.V[0]

        elif first == 0xC:
            # CXNN: Set VX = random AND NN
            self.V[x] = random.randint(0, 255) & nn
            self.PC += 2

        elif first == 0xD:
            # DXYN: Draw sprite at (VX, VY) with N bytes of sprite data starting at I
            # VF = 1 if any pixels flipped from on to off (collision)
            x_pos = self.V[x] % 64
            y_pos = self.V[y] % 32
            self.V[0xF] = 0

            for row in range(n):
                if y_pos + row >= 32:
                    break
                sprite_byte = self.memory[self.I + row]
                for col in range(8):
                    if x_pos + col >= 64:
                        break
                    if sprite_byte & (0x80 >> col):
                        if self.display[y_pos + row][x_pos + col] == 1:
                            self.V[0xF] = 1
                        self.display[y_pos + row][x_pos + col] ^= 1

            self.draw_flag = True
            self.PC += 2

        elif first == 0xE:
            if nn == 0x9E:
                # EX9E: Skip next if key VX is pressed
                if self.keys[self.V[x] & 0xF]:
                    self.PC += 4
                else:
                    self.PC += 2

            elif nn == 0xA1:
                # EXA1: Skip next if key VX is NOT pressed
                if not self.keys[self.V[x] & 0xF]:
                    self.PC += 4
                else:
                    self.PC += 2
            else:
                self.PC += 2

        elif first == 0xF:
            if nn == 0x07:
                # FX07: Set VX = delay timer
                self.V[x] = self.delay_timer
                self.PC += 2

            elif nn == 0x0A:
                # FX0A: Wait for key press, store in VX
                self.waiting_for_key = True
                self.key_register = x
                self.PC += 2

            elif nn == 0x15:
                # FX15: Set delay timer = VX
                self.delay_timer = self.V[x]
                self.PC += 2

            elif nn == 0x18:
                # FX18: Set sound timer = VX
                self.sound_timer = self.V[x]
                self.PC += 2

            elif nn == 0x1E:
                # FX1E: Set I = I + VX
                self.I = (self.I + self.V[x]) & 0xFFFF
                self.PC += 2

            elif nn == 0x29:
                # FX29: Set I = sprite address for hex digit VX
                self.I = (self.V[x] & 0xF) * 5
                self.PC += 2

            elif nn == 0x33:
                # FX33: Store BCD of VX at I, I+1, I+2
                value = self.V[x]
                self.memory[self.I] = value // 100
                self.memory[self.I + 1] = (value // 10) % 10
                self.memory[self.I + 2] = value % 10
                self.PC += 2

            elif nn == 0x55:
                # FX55: Store V0-VX in memory starting at I
                for i in range(x + 1):
                    self.memory[self.I + i] = self.V[i]
                self.I += x + 1  # Original behavior
                self.PC += 2

            elif nn == 0x65:
                # FX65: Load V0-VX from memory starting at I
                for i in range(x + 1):
                    self.V[i] = self.memory[self.I + i]
                self.I += x + 1  # Original behavior
                self.PC += 2
            else:
                self.PC += 2
        else:
            # Unknown opcode
            self.PC += 2

    def update_timers(self):
        """Update delay and sound timers (call at 60Hz)"""
        if self.delay_timer > 0:
            self.delay_timer -= 1

        if self.sound_timer > 0:
            self.sound_flag = True
            self.sound_timer -= 1
        else:
            self.sound_flag = False

    def key_press(self, key: int):
        """Handle key press"""
        if 0 <= key <= 0xF:
            self.keys[key] = 1
            if self.waiting_for_key:
                self.V[self.key_register] = key
                self.waiting_for_key = False

    def key_release(self, key: int):
        """Handle key release"""
        if 0 <= key <= 0xF:
            self.keys[key] = 0


class Chip8Emulator:
    """Main emulator class with Tkinter GUI styled after Project64"""

    def __init__(self):
        self.cpu = Chip8CPU()
        self.cycles_per_frame = 10  # ~600Hz at 60fps
        self.running = False
        self.rom_loaded = False
        self.current_rom_path = None

        # Display settings
        self.scale = 8  # Each CHIP-8 pixel = 8x8 screen pixels
        self.fg_color = "#00FF00"  # Green phosphor
        self.bg_color = "#001100"  # Dark green

        self.setup_gui()

    def setup_gui(self):
        """Create the Project64-style GUI"""
        self.root = tk.Tk()
        self.root.title("Cat's Chip 8 Emulator")
        self.root.geometry("600x400")
        self.root.resizable(True, True)
        self.root.configure(bg='#2D2D30')

        # Configure style for dark theme
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self.style.configure('Dark.TFrame', background='#2D2D30')
        self.style.configure('Dark.TLabel', background='#2D2D30', foreground='#FFFFFF')
        self.style.configure('Dark.TButton', background='#3E3E42', foreground='#FFFFFF')
        self.style.configure('Status.TLabel', background='#007ACC', foreground='#FFFFFF', padding=2)

        # Create menu bar
        self.create_menu()

        # Create toolbar
        self.create_toolbar()

        # Main container
        self.main_frame = ttk.Frame(self.root, style='Dark.TFrame')
        self.main_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

        # Display canvas (64x32 scaled)
        canvas_width = 64 * self.scale
        canvas_height = 32 * self.scale

        self.canvas_frame = ttk.Frame(self.main_frame, style='Dark.TFrame')
        self.canvas_frame.pack(fill=tk.BOTH, expand=True)

        self.canvas = tk.Canvas(
            self.canvas_frame,
            width=canvas_width,
            height=canvas_height,
            bg=self.bg_color,
            highlightthickness=2,
            highlightbackground='#505050'
        )
        self.canvas.pack(expand=True)

        # Create pixel rectangles for efficient updates
        self.pixels = []
        for y in range(32):
            row = []
            for x in range(64):
                rect = self.canvas.create_rectangle(
                    x * self.scale, y * self.scale,
                    (x + 1) * self.scale, (y + 1) * self.scale,
                    fill=self.bg_color, outline=''
                )
                row.append(rect)
            self.pixels.append(row)

        # Status bar
        self.create_status_bar()

        # Bind keyboard events
        self.root.bind('<KeyPress>', self.on_key_press)
        self.root.bind('<KeyRelease>', self.on_key_release)

        # Focus canvas for keyboard input
        self.canvas.focus_set()

        # Handle window close
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)

        # Welcome message on display
        self.show_welcome()

    def create_menu(self):
        """Create Project64-style menu bar"""
        self.menubar = tk.Menu(self.root, bg='#2D2D30', fg='#FFFFFF',
                               activebackground='#094771', activeforeground='#FFFFFF')
        self.root.config(menu=self.menubar)

        # File menu
        file_menu = tk.Menu(self.menubar, tearoff=0, bg='#2D2D30', fg='#FFFFFF',
                           activebackground='#094771', activeforeground='#FFFFFF')
        self.menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="Open ROM...", command=self.open_rom, accelerator="Ctrl+O")
        file_menu.add_command(label="Close ROM", command=self.close_rom)
        file_menu.add_separator()
        file_menu.add_command(label="Recent ROMs", state=tk.DISABLED)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.on_close, accelerator="Alt+F4")

        # System menu
        system_menu = tk.Menu(self.menubar, tearoff=0, bg='#2D2D30', fg='#FFFFFF',
                             activebackground='#094771', activeforeground='#FFFFFF')
        self.menubar.add_cascade(label="System", menu=system_menu)
        system_menu.add_command(label="Start", command=self.start_emulation, accelerator="F5")
        system_menu.add_command(label="Pause", command=self.pause_emulation, accelerator="F6")
        system_menu.add_command(label="Reset", command=self.reset_emulation, accelerator="F7")
        system_menu.add_separator()

        # Speed submenu
        speed_menu = tk.Menu(system_menu, tearoff=0, bg='#2D2D30', fg='#FFFFFF',
                            activebackground='#094771', activeforeground='#FFFFFF')
        system_menu.add_cascade(label="Speed", menu=speed_menu)
        speed_menu.add_command(label="Slow (300Hz)", command=lambda: self.set_speed(5))
        speed_menu.add_command(label="Normal (600Hz)", command=lambda: self.set_speed(10))
        speed_menu.add_command(label="Fast (1200Hz)", command=lambda: self.set_speed(20))
        speed_menu.add_command(label="Very Fast (1800Hz)", command=lambda: self.set_speed(30))

        # Options menu
        options_menu = tk.Menu(self.menubar, tearoff=0, bg='#2D2D30', fg='#FFFFFF',
                              activebackground='#094771', activeforeground='#FFFFFF')
        self.menubar.add_cascade(label="Options", menu=options_menu)

        # Color schemes submenu
        colors_menu = tk.Menu(options_menu, tearoff=0, bg='#2D2D30', fg='#FFFFFF',
                             activebackground='#094771', activeforeground='#FFFFFF')
        options_menu.add_cascade(label="Color Scheme", menu=colors_menu)
        colors_menu.add_command(label="Classic Green", command=lambda: self.set_colors("#00FF00", "#001100"))
        colors_menu.add_command(label="Amber", command=lambda: self.set_colors("#FFB000", "#1A0F00"))
        colors_menu.add_command(label="White", command=lambda: self.set_colors("#FFFFFF", "#000000"))
        colors_menu.add_command(label="Blue", command=lambda: self.set_colors("#00BFFF", "#000022"))
        colors_menu.add_command(label="Purple", command=lambda: self.set_colors("#FF00FF", "#110011"))

        # Help menu
        help_menu = tk.Menu(self.menubar, tearoff=0, bg='#2D2D30', fg='#FFFFFF',
                           activebackground='#094771', activeforeground='#FFFFFF')
        self.menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Controls", command=self.show_controls)
        help_menu.add_command(label="About", command=self.show_about)

        # Keyboard shortcuts
        self.root.bind('<Control-o>', lambda e: self.open_rom())
        self.root.bind('<F5>', lambda e: self.start_emulation())
        self.root.bind('<F6>', lambda e: self.pause_emulation())
        self.root.bind('<F7>', lambda e: self.reset_emulation())

    def create_toolbar(self):
        """Create Project64-style toolbar"""
        toolbar = ttk.Frame(self.root, style='Dark.TFrame')
        toolbar.pack(fill=tk.X, padx=2, pady=2)

        # Toolbar buttons
        btn_style = {'bg': '#3E3E42', 'fg': '#FFFFFF', 'relief': tk.FLAT,
                    'activebackground': '#505050', 'activeforeground': '#FFFFFF',
                    'padx': 10, 'pady': 2}

        self.btn_open = tk.Button(toolbar, text="Open", command=self.open_rom, **btn_style)
        self.btn_open.pack(side=tk.LEFT, padx=1)

        ttk.Separator(toolbar, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=5)

        self.btn_start = tk.Button(toolbar, text="Start", command=self.start_emulation, **btn_style)
        self.btn_start.pack(side=tk.LEFT, padx=1)

        self.btn_pause = tk.Button(toolbar, text="Pause", command=self.pause_emulation, **btn_style)
        self.btn_pause.pack(side=tk.LEFT, padx=1)

        self.btn_reset = tk.Button(toolbar, text="Reset", command=self.reset_emulation, **btn_style)
        self.btn_reset.pack(side=tk.LEFT, padx=1)

        ttk.Separator(toolbar, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=5)

        # Speed label
        tk.Label(toolbar, text="Speed:", bg='#2D2D30', fg='#FFFFFF').pack(side=tk.LEFT, padx=5)

        self.speed_var = tk.StringVar(value="Normal")
        speed_combo = ttk.Combobox(toolbar, textvariable=self.speed_var, width=10,
                                   values=["Slow", "Normal", "Fast", "Very Fast"], state='readonly')
        speed_combo.pack(side=tk.LEFT, padx=2)
        speed_combo.bind('<<ComboboxSelected>>', self.on_speed_change)

    def create_status_bar(self):
        """Create Project64-style status bar"""
        status_frame = tk.Frame(self.root, bg='#007ACC', height=22)
        status_frame.pack(fill=tk.X, side=tk.BOTTOM)
        status_frame.pack_propagate(False)

        self.status_label = tk.Label(status_frame, text="Ready - No ROM loaded",
                                     bg='#007ACC', fg='#FFFFFF', anchor=tk.W)
        self.status_label.pack(side=tk.LEFT, padx=5)

        self.fps_label = tk.Label(status_frame, text="FPS: --",
                                  bg='#007ACC', fg='#FFFFFF', anchor=tk.E)
        self.fps_label.pack(side=tk.RIGHT, padx=5)

        self.cpu_label = tk.Label(status_frame, text="CPU: Idle",
                                  bg='#007ACC', fg='#FFFFFF', anchor=tk.E)
        self.cpu_label.pack(side=tk.RIGHT, padx=15)

    def show_welcome(self):
        """Show welcome message on display"""
        # Draw "CHIP-8" text pattern
        welcome_pattern = [
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "       CCCC  H  H  III  PPP       888                           ",
            "      C      H  H   I   P  P     8   8                          ",
            "      C      HHHH   I   PPP   --  888                           ",
            "      C      H  H   I   P        8   8                          ",
            "       CCCC  H  H  III  P         888                           ",
            "                                                                ",
            "                                                                ",
            "                Press Ctrl+O to load ROM                        ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
            "                                                                ",
        ]

        for y, row in enumerate(welcome_pattern):
            for x, char in enumerate(row):
                if char != ' ' and x < 64 and y < 32:
                    self.canvas.itemconfig(self.pixels[y][x], fill=self.fg_color)

    def open_rom(self):
        """Open ROM file dialog"""
        filetypes = [
            ("CHIP-8 ROMs", "*.ch8 *.c8 *.rom *.bin"),
            ("All files", "*.*")
        ]
        filepath = filedialog.askopenfilename(
            title="Open CHIP-8 ROM",
            filetypes=filetypes
        )

        if filepath:
            self.load_rom(filepath)

    def load_rom(self, filepath: str):
        """Load ROM from file"""
        try:
            with open(filepath, 'rb') as f:
                rom_data = f.read()

            if self.cpu.load_rom(rom_data):
                self.rom_loaded = True
                self.current_rom_path = filepath
                rom_name = os.path.basename(filepath)
                self.root.title(f"Cat's Chip 8 Emulator - {rom_name}")
                self.status_label.config(text=f"Loaded: {rom_name} ({len(rom_data)} bytes)")
                self.update_display()

                # Auto-start
                self.start_emulation()
            else:
                messagebox.showerror("Error", "ROM file too large (max 3584 bytes)")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load ROM: {str(e)}")

    def close_rom(self):
        """Close current ROM"""
        self.stop_emulation()
        self.cpu.reset()
        self.rom_loaded = False
        self.current_rom_path = None
        self.root.title("Cat's Chip 8 Emulator")
        self.status_label.config(text="Ready - No ROM loaded")
        self.clear_display()
        self.show_welcome()

    def start_emulation(self):
        """Start or resume emulation"""
        if not self.rom_loaded:
            messagebox.showinfo("Info", "Please load a ROM first (Ctrl+O)")
            return

        if not self.running:
            self.running = True
            self.cpu.paused = False
            self.cpu.running = True
            self.status_label.config(text=f"Running: {os.path.basename(self.current_rom_path)}")
            self.cpu_label.config(text="CPU: Running")
            self.emulation_thread = threading.Thread(target=self.emulation_loop, daemon=True)
            self.emulation_thread.start()
        else:
            self.cpu.paused = False
            self.status_label.config(text=f"Running: {os.path.basename(self.current_rom_path)}")
            self.cpu_label.config(text="CPU: Running")

    def pause_emulation(self):
        """Pause emulation"""
        if self.running and not self.cpu.paused:
            self.cpu.paused = True
            self.status_label.config(text=f"Paused: {os.path.basename(self.current_rom_path)}")
            self.cpu_label.config(text="CPU: Paused")

    def stop_emulation(self):
        """Stop emulation completely"""
        self.running = False
        self.cpu.running = False
        self.cpu_label.config(text="CPU: Idle")

    def reset_emulation(self):
        """Reset and restart emulation"""
        if self.current_rom_path:
            was_running = self.running
            self.stop_emulation()
            time.sleep(0.05)  # Brief pause
            self.load_rom(self.current_rom_path)
            if was_running:
                self.start_emulation()

    def emulation_loop(self):
        """Main emulation loop (runs in separate thread)"""
        frame_time = 1.0 / 60  # 60 FPS target
        last_time = time.time()
        frame_count = 0
        fps_update_time = last_time

        while self.running:
            current_time = time.time()

            if not self.cpu.paused:
                # Execute CPU cycles
                for _ in range(self.cycles_per_frame):
                    self.cpu.cycle()

                # Update timers at 60Hz
                self.cpu.update_timers()

                # Update display if needed
                if self.cpu.draw_flag:
                    self.root.after(0, self.update_display)
                    self.cpu.draw_flag = False

                # Handle sound
                if self.cpu.sound_flag:
                    self.root.after(0, self.beep)

            # FPS counter
            frame_count += 1
            if current_time - fps_update_time >= 1.0:
                fps = frame_count / (current_time - fps_update_time)
                self.root.after(0, lambda f=fps: self.fps_label.config(text=f"FPS: {f:.1f}"))
                frame_count = 0
                fps_update_time = current_time

            # Frame timing
            elapsed = time.time() - current_time
            sleep_time = frame_time - elapsed
            if sleep_time > 0:
                time.sleep(sleep_time)

    def update_display(self):
        """Update canvas from CPU display buffer"""
        for y in range(32):
            for x in range(64):
                color = self.fg_color if self.cpu.display[y][x] else self.bg_color
                self.canvas.itemconfig(self.pixels[y][x], fill=color)

    def clear_display(self):
        """Clear the display"""
        for y in range(32):
            for x in range(64):
                self.canvas.itemconfig(self.pixels[y][x], fill=self.bg_color)

    def beep(self):
        """Play beep sound"""
        # Simple system bell - cross-platform
        self.root.bell()

    def on_key_press(self, event):
        """Handle keyboard press"""
        key = event.keysym.lower()
        if key in KEY_MAP:
            self.cpu.key_press(KEY_MAP[key])

    def on_key_release(self, event):
        """Handle keyboard release"""
        key = event.keysym.lower()
        if key in KEY_MAP:
            self.cpu.key_release(KEY_MAP[key])

    def on_speed_change(self, event):
        """Handle speed combobox change"""
        speeds = {"Slow": 5, "Normal": 10, "Fast": 20, "Very Fast": 30}
        self.cycles_per_frame = speeds.get(self.speed_var.get(), 10)

    def set_speed(self, cycles: int):
        """Set emulation speed"""
        self.cycles_per_frame = cycles
        names = {5: "Slow", 10: "Normal", 20: "Fast", 30: "Very Fast"}
        self.speed_var.set(names.get(cycles, "Normal"))

    def set_colors(self, fg: str, bg: str):
        """Set display colors"""
        self.fg_color = fg
        self.bg_color = bg
        self.canvas.configure(bg=bg)
        self.update_display()

    def show_controls(self):
        """Show controls help dialog"""
        controls = """
CHIP-8 Keypad    Keyboard
-----------      --------
1 2 3 C          1 2 3 4
4 5 6 D          Q W E R
7 8 9 E          A S D F
A 0 B F          Z X C V

Emulator Controls:
------------------
Ctrl+O    Open ROM
F5        Start
F6        Pause
F7        Reset
"""
        messagebox.showinfo("Controls", controls)

    def show_about(self):
        """Show about dialog"""
        about = """
Cat's Chip 8 Emulator

A complete CHIP-8 emulator with:
- All 35 original opcodes
- 64x32 pixel display
- 16-key hexadecimal keypad
- Delay and sound timers
- Variable speed emulation

Styled after Project64 1.0

CHIP-8 was created by
Joseph Weisbecker in 1977
"""
        messagebox.showinfo("About", about)

    def on_close(self):
        """Handle window close"""
        self.stop_emulation()
        self.root.destroy()

    def run(self):
        """Start the emulator"""
        self.root.mainloop()


# Debug/Test utilities
class Chip8Disassembler:
    """Disassembler for CHIP-8 opcodes (useful for debugging)"""

    @staticmethod
    def disassemble(opcode: int) -> str:
        """Disassemble a single opcode to readable string"""
        nnn = opcode & 0x0FFF
        nn = opcode & 0x00FF
        n = opcode & 0x000F
        x = (opcode & 0x0F00) >> 8
        y = (opcode & 0x00F0) >> 4
        first = (opcode & 0xF000) >> 12

        if opcode == 0x00E0:
            return "CLS"
        elif opcode == 0x00EE:
            return "RET"
        elif first == 0x0:
            return f"SYS {nnn:03X}"
        elif first == 0x1:
            return f"JP {nnn:03X}"
        elif first == 0x2:
            return f"CALL {nnn:03X}"
        elif first == 0x3:
            return f"SE V{x:X}, {nn:02X}"
        elif first == 0x4:
            return f"SNE V{x:X}, {nn:02X}"
        elif first == 0x5:
            return f"SE V{x:X}, V{y:X}"
        elif first == 0x6:
            return f"LD V{x:X}, {nn:02X}"
        elif first == 0x7:
            return f"ADD V{x:X}, {nn:02X}"
        elif first == 0x8:
            ops = {0: "LD", 1: "OR", 2: "AND", 3: "XOR", 4: "ADD",
                   5: "SUB", 6: "SHR", 7: "SUBN", 0xE: "SHL"}
            return f"{ops.get(n, '???')} V{x:X}, V{y:X}"
        elif first == 0x9:
            return f"SNE V{x:X}, V{y:X}"
        elif first == 0xA:
            return f"LD I, {nnn:03X}"
        elif first == 0xB:
            return f"JP V0, {nnn:03X}"
        elif first == 0xC:
            return f"RND V{x:X}, {nn:02X}"
        elif first == 0xD:
            return f"DRW V{x:X}, V{y:X}, {n}"
        elif first == 0xE:
            if nn == 0x9E:
                return f"SKP V{x:X}"
            elif nn == 0xA1:
                return f"SKNP V{x:X}"
        elif first == 0xF:
            ops = {0x07: "LD V{}, DT", 0x0A: "LD V{}, K", 0x15: "LD DT, V{}",
                   0x18: "LD ST, V{}", 0x1E: "ADD I, V{}", 0x29: "LD F, V{}",
                   0x33: "LD B, V{}", 0x55: "LD [I], V{}", 0x65: "LD V{}, [I]"}
            if nn in ops:
                return ops[nn].format(f"{x:X}")
        return f"??? {opcode:04X}"


def main():
    """Main entry point"""
    emulator = Chip8Emulator()
    emulator.run()


if __name__ == "__main__":
    main()